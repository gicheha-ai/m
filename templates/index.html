<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EUR/USD Auto-Learning Trading System</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --primary-color: #00ff88;
            --secondary-color: #00ccff;
            --danger-color: #ff416c;
            --warning-color: #ffcc00;
            --dark-bg: #0f2027;
            --darker-bg: #0a1a1f;
            --card-bg: rgba(255, 255, 255, 0.05);
            --border-color: rgba(255, 255, 255, 0.1);
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--dark-bg), #203a43, #2c5364);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
        }
        
        /* Header */
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 25px;
            background: var(--card-bg);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .header h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }
        
        .header p {
            color: #aaa;
            font-size: 1.2rem;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
        }
        
        /* System Status Bar */
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px 25px;
            border-radius: 15px;
            margin-bottom: 30px;
            border: 1px solid var(--border-color);
        }
        
        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .status-green { background-color: var(--primary-color); }
        .status-yellow { background-color: var(--warning-color); }
        .status-red { background-color: var(--danger-color); }
        
        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
            border-color: var(--primary-color);
            box-shadow: 0 10px 20px rgba(0, 255, 136, 0.1);
        }
        
        .stat-card h3 {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .stat-value {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 10px;
            font-family: 'Courier New', monospace;
        }
        
        .stat-label {
            color: #aaa;
            font-size: 0.95rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .stat-change {
            font-size: 0.9rem;
            padding: 3px 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .stat-change.positive { color: var(--primary-color); }
        .stat-change.negative { color: var(--danger-color); }
        
        /* Chart Container */
        .chart-container {
            background: var(--card-bg);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 30px;
            border: 1px solid var(--border-color);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .chart-header h3 {
            font-size: 1.5rem;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        /* Trade Panel */
        .trade-panel {
            background: var(--card-bg);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 30px;
            border: 1px solid var(--border-color);
        }
        
        .trade-active {
            border-color: var(--primary-color);
            animation: glow 2s infinite;
        }
        
        @keyframes glow {
            0% { box-shadow: 0 0 0 0 rgba(0, 255, 136, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(0, 255, 136, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 255, 136, 0); }
        }
        
        .trade-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .trade-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid var(--border-color);
        }
        
        /* ML Panel */
        .ml-panel {
            background: var(--card-bg);
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 30px;
            border: 1px solid var(--border-color);
        }
        
        .ml-progress {
            margin-top: 20px;
        }
        
        .progress-container {
            margin-bottom: 15px;
        }
        
        .progress-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            color: #aaa;
        }
        
        .progress-bar {
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            border-radius: 5px;
            transition: width 1s ease;
        }
        
        /* Controls */
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 150px;
            justify-content: center;
        }
        
        .btn-primary {
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            color: #000;
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid var(--border-color);
        }
        
        .btn-danger {
            background: linear-gradient(90deg, var(--danger-color), #ff4b2b);
            color: #fff;
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }
        
        .btn:active {
            transform: translateY(-1px);
        }
        
        /* History Panel */
        .history-panel {
            background: var(--card-bg);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid var(--border-color);
        }
        
        .history-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        .history-table th,
        .history-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        
        .history-table th {
            color: var(--primary-color);
            font-weight: 600;
        }
        
        .history-table tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .profit-positive {
            color: var(--primary-color);
        }
        
        .profit-negative {
            color: var(--danger-color);
        }
        
        /* Footer */
        .footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            color: #666;
            font-size: 0.9rem;
            border-top: 1px solid var(--border-color);
        }
        
        /* Notification */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.9);
            border-left: 4px solid var(--primary-color);
            display: none;
            z-index: 1000;
            max-width: 400px;
            backdrop-filter: blur(10px);
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .notification.error {
            border-left-color: var(--danger-color);
        }
        
        .notification.warning {
            border-left-color: var(--warning-color);
        }
        
        /* Responsive */
        @media (max-width: 1200px) {
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        @media (max-width: 768px) {
            .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
            }
            
            .header h1 {
                font-size: 2rem;
                flex-direction: column;
            }
            
            .status-bar {
                flex-direction: column;
                gap: 15px;
                align-items: flex-start;
            }
        }
        
        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Trading Signals */
        .signal-strength {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        
        .signal-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
        }
        
        .signal-dot.active {
            background: var(--primary-color);
        }
        
        /* ML Accuracy Gauge */
        .ml-accuracy {
            text-align: center;
            margin-top: 20px;
        }
        
        .accuracy-gauge {
            width: 150px;
            height: 150px;
            margin: 0 auto;
            position: relative;
        }
        
        .accuracy-value {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            font-weight: bold;
            color: var(--primary-color);
        }
        
        /* Additional CSS for real-time updates */
        .updating {
            animation: highlight 0.5s ease;
        }
        
        @keyframes highlight {
            0% { background-color: rgba(0, 255, 136, 0.1); }
            100% { background-color: transparent; }
        }
        
        /* Auto-refresh indicator */
        .refresh-indicator {
            position: fixed;
            bottom: 10px;
            left: 10px;
            font-size: 11px;
            color: #666;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .refresh-indicator .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background-color: var(--primary-color);
            animation: blink 2s infinite;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>
                <i class="fas fa-brain"></i>
                EUR/USD Auto-Learning Trading System
                <i class="fas fa-robot"></i>
            </h1>
            <p>Advanced 2-minute trading cycles with Machine Learning that auto-corrects and improves accuracy over time</p>
        </div>

        <!-- System Status Bar -->
        <div class="status-bar">
            <div class="status-item">
                <span class="status-indicator status-green" id="system-status-indicator"></span>
                <span id="system-status-text">SYSTEM INITIALIZING...</span>
            </div>
            <div class="status-item">
                <i class="fas fa-sync-alt"></i>
                <span>Cycle: <span id="cycle-count">0</span> | Next: <span id="next-cycle">120</span>s</span>
            </div>
            <div class="status-item">
                <i class="fas fa-database"></i>
                <span>Cache: <span id="cache-efficiency">0%</span> | API: <span id="api-calls">~240/day</span></span>
            </div>
            <div class="status-item">
                <i class="fas fa-brain"></i>
                <span>ML: <span id="ml-status">LEARNING...</span> | Samples: <span id="ml-samples">0</span></span>
            </div>
        </div>

        <!-- Main Stats Grid -->
        <div class="stats-grid">
            <!-- Price Card -->
            <div class="stat-card">
                <h3><i class="fas fa-chart-line"></i> EUR/USD Price</h3>
                <div class="stat-value" id="current-price">1.08500</div>
                <div class="stat-label">
                    <span id="price-source">Source: Loading...</span>
                    <span class="stat-change" id="price-change">+0.0000</span>
                </div>
            </div>

            <!-- Prediction Card -->
            <div class="stat-card">
                <h3><i class="fas fa-bullhorn"></i> 2-Minute Prediction</h3>
                <div class="stat-value" id="prediction">ANALYZING</div>
                <div class="stat-label">
                    <span>Confidence: <span id="confidence">0%</span></span>
                    <div class="signal-strength" id="signal-strength">
                        <div class="signal-dot"></div>
                        <div class="signal-dot"></div>
                        <div class="signal-dot"></div>
                    </div>
                </div>
            </div>

            <!-- Trade Action Card -->
            <div class="stat-card">
                <h3><i class="fas fa-exchange-alt"></i> Trading Action</h3>
                <div class="stat-value" id="action">WAIT</div>
                <div class="stat-label">
                    <span>Status: <span id="trade-status">NO_TRADE</span></span>
                    <span>Signal: <span id="signal-value">0/3</span></span>
                </div>
            </div>

            <!-- Balance Card -->
            <div class="stat-card">
                <h3><i class="fas fa-wallet"></i> Balance</h3>
                <div class="stat-value" id="balance">$10,000.00</div>
                <div class="stat-label">
                    <span>Profit: <span id="total-profit">$0.00</span></span>
                    <span class="stat-change" id="profit-change">+$0.00</span>
                </div>
            </div>

            <!-- Performance Card -->
            <div class="stat-card">
                <h3><i class="fas fa-trophy"></i> Performance</h3>
                <div class="stat-value" id="win-rate">0%</div>
                <div class="stat-label">
                    <span>Trades: <span id="total-trades">0</span></span>
                    <span>Wins: <span id="profitable-trades">0</span></span>
                </div>
            </div>

            <!-- ML Accuracy Card -->
            <div class="stat-card">
                <h3><i class="fas fa-robot"></i> ML Accuracy</h3>
                <div class="stat-value" id="ml-accuracy">0%</div>
                <div class="stat-label">
                    <span>Learning Rate: <span id="learning-rate">0%</span></span>
                    <span>Corrections: <span id="ml-corrections">0</span></span>
                </div>
            </div>
        </div>

        <!-- Chart Section -->
        <div class="chart-container">
            <div class="chart-header">
                <h3><i class="fas fa-chart-area"></i> Live Trading Chart</h3>
                <div class="chart-controls">
                    <button class="btn btn-secondary" onclick="toggleChartType()">
                        <i class="fas fa-sync"></i> Switch View
                    </button>
                </div>
            </div>
            <div id="chart" style="width:100%; height:500px;"></div>
        </div>

        <!-- Trading Panel -->
        <div class="trade-panel" id="trade-panel">
            <h3><i class="fas fa-trade"></i> Active Trade</h3>
            <div id="trade-details">
                <p style="text-align: center; color: #aaa; padding: 20px;">No active trade</p>
            </div>
            <div class="trade-info" id="trade-info" style="display: none;">
                <div class="trade-item">
                    <h4>Entry Price</h4>
                    <div class="stat-value" id="trade-entry">1.08500</div>
                </div>
                <div class="trade-item">
                    <h4>Current P/L</h4>
                    <div class="stat-value" id="trade-pl">+0.0 pips</div>
                </div>
                <div class="trade-item">
                    <h4>Take Profit</h4>
                    <div class="stat-value" id="trade-tp">1.08580</div>
                    <div class="stat-label">Distance: <span id="tp-distance">8 pips</span></div>
                </div>
                <div class="trade-item">
                    <h4>Stop Loss</h4>
                    <div class="stat-value" id="trade-sl">1.08450</div>
                    <div class="stat-label">Distance: <span id="sl-distance">5 pips</span></div>
                </div>
                <div class="trade-item">
                    <h4>Time Remaining</h4>
                    <div class="stat-value" id="trade-time">120s</div>
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress-fill" id="trade-progress-bar" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ML Learning Panel -->
        <div class="ml-panel">
            <h3><i class="fas fa-graduation-cap"></i> Machine Learning Status</h3>
            <div class="ml-progress">
                <div class="progress-container">
                    <div class="progress-label">
                        <span>Training Data Collection</span>
                        <span id="training-progress-text">0/10 trades</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="training-progress" style="width: 0%"></div>
                    </div>
                </div>
                <div class="progress-container">
                    <div class="progress-label">
                        <span>Prediction Accuracy</span>
                        <span id="accuracy-text">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="accuracy-progress" style="width: 0%"></div>
                    </div>
                </div>
                <div class="progress-container">
                    <div class="progress-label">
                        <span>ML Model Confidence</span>
                        <span id="model-confidence-text">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="model-confidence" style="width: 0%"></div>
                    </div>
                </div>
            </div>
            <div class="ml-stats" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-top: 20px;">
                <div class="stat-card">
                    <h4>Auto-Corrections</h4>
                    <div class="stat-value" id="ml-corrections-count">0</div>
                    <div class="stat-label">TP/SL adjustments</div>
                </div>
                <div class="stat-card">
                    <h4>Learning Rate</h4>
                    <div class="stat-value" id="learning-rate-value">0.0%</div>
                    <div class="stat-label">Improvement per trade</div>
                </div>
                <div class="stat-card">
                    <h4>Data Quality</h4>
                    <div class="stat-value" id="data-quality">0%</div>
                    <div class="stat-label">Training samples</div>
                </div>
            </div>
        </div>

        <!-- Controls -->
        <div class="controls">
            <button class="btn btn-primary" onclick="refreshAllData()">
                <i class="fas fa-sync-alt"></i> Refresh All Data
            </button>
            <button class="btn btn-secondary" onclick="viewTradeHistory()">
                <i class="fas fa-history"></i> View Trade History
            </button>
            <button class="btn btn-secondary" onclick="viewMLData()">
                <i class="fas fa-database"></i> View ML Data
            </button>
            <button class="btn btn-secondary" onclick="viewAdvancedMetrics()">
                <i class="fas fa-chart-bar"></i> Advanced Metrics
            </button>
            <button class="btn btn-secondary" onclick="forceMLTraining()">
                <i class="fas fa-brain"></i> Force ML Training
            </button>
            <button class="btn btn-danger" onclick="resetTrading()">
                <i class="fas fa-redo"></i> Reset Trading
            </button>
        </div>

        <!-- History Panel -->
        <div class="history-panel">
            <h3><i class="fas fa-list-alt"></i> Recent Trades</h3>
            <table class="history-table" id="trade-history-table">
                <thead>
                    <tr>
                        <th>ID</th>
                        <th>Action</th>
                        <th>Entry</th>
                        <th>Exit</th>
                        <th>P/L (Pips)</th>
                        <th>Result</th>
                        <th>Confidence</th>
                        <th>Time</th>
                    </tr>
                </thead>
                <tbody id="trade-history-body">
                    <tr>
                        <td colspan="8" style="text-align: center; padding: 30px; color: #666;">
                            <i class="fas fa-clock"></i> Waiting for trades...
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- Footer -->
        <div class="footer">
            <p>EUR/USD Auto-Learning Trading System v3.0 | Real-time updates every 2 seconds | ML accuracy improves with each trade</p>
            <p style="margin-top: 10px; font-size: 0.8rem; color: #444;">
                <i class="fas fa-shield-alt"></i> API-SAFE with 30-second caching | 
                <i class="fas fa-bolt"></i> Real-time ML learning | 
                <i class="fas fa-chart-line"></i> Auto-correcting predictions
            </p>
        </div>
    </div>

    <!-- Notification -->
    <div class="notification" id="notification">
        <div id="notification-message"></div>
    </div>

    <!-- Refresh Indicator -->
    <div class="refresh-indicator" id="refresh-indicator">
        <div class="dot"></div>
        <span>Real-time updates active</span>
    </div>

    <!-- Loading Overlay -->
    <div id="loading-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 9999; display: flex; align-items: center; justify-content: center;">
        <div style="background: var(--card-bg); padding: 30px; border-radius: 10px; text-align: center;">
            <div class="loading" style="width: 40px; height: 40px; margin: 0 auto 20px;"></div>
            <p>Connecting to trading system...</p>
        </div>
    </div>

    <script>
        // Global trading system instance
        let tradingSystem = null;

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('ðŸ“ˆ EUR/USD Trading System Initializing...');
            
            // Show loading overlay
            document.getElementById('loading-overlay').style.display = 'flex';
            
            // Create and initialize trading system
            tradingSystem = new TradingSystem();
            
            // Set up keyboard shortcuts
            setupKeyboardShortcuts();
            
            // Set up auto-refresh indicator
            setupAutoRefreshIndicator();
            
            // Start periodic health check
            setInterval(checkSystemHealth, 30000);
            
            console.log('âœ… Trading System Ready');
        });

        // Keyboard shortcuts
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', function(e) {
                // Ctrl + R = Refresh all data
                if (e.ctrlKey && e.key === 'r') {
                    e.preventDefault();
                    refreshAllData();
                }
                // Ctrl + H = View trade history
                else if (e.ctrlKey && e.key === 'h') {
                    e.preventDefault();
                    viewTradeHistory();
                }
                // Ctrl + M = View ML data
                else if (e.ctrlKey && e.key === 'm') {
                    e.preventDefault();
                    viewMLData();
                }
                // Escape = Close notification
                else if (e.key === 'Escape') {
                    const notification = document.getElementById('notification');
                    if (notification) notification.style.display = 'none';
                }
            });
        }

        // Auto-refresh indicator
        function setupAutoRefreshIndicator() {
            const indicator = document.getElementById('refresh-indicator');
            let blinkCount = 0;
            
            setInterval(() => {
                blinkCount++;
                indicator.style.opacity = blinkCount % 2 === 0 ? '0.7' : '1';
            }, 1000);
        }

        // System health check
        async function checkSystemHealth() {
            try {
                const response = await fetch('/api/health');
                const data = await response.json();
                
                if (data.status !== 'running') {
                    console.warn('âš ï¸ System health check failed:', data);
                    // Attempt to reconnect
                    if (tradingSystem) {
                        tradingSystem.setupEventSource();
                    }
                }
            } catch (error) {
                console.error('Health check error:', error);
            }
        }

        // Global functions for HTML onclick handlers
        function refreshAllData() {
            if (tradingSystem) {
                tradingSystem.refreshAllData();
            }
        }

        function viewTradeHistory() {
            if (tradingSystem) {
                tradingSystem.viewTradeHistory();
            }
        }

        function viewMLData() {
            if (tradingSystem) {
                tradingSystem.viewMLData();
            }
        }

        function viewAdvancedMetrics() {
            if (tradingSystem) {
                tradingSystem.viewAdvancedMetrics();
            }
        }

        function forceMLTraining() {
            if (tradingSystem) {
                tradingSystem.forceMLTraining();
            }
        }

        function resetTrading() {
            if (tradingSystem) {
                tradingSystem.resetTrading();
            }
        }

        function toggleChartType() {
            // This would toggle between different chart views
            if (tradingSystem) {
                tradingSystem.showNotification('Chart view toggled', 'success');
            }
        }

        // Add CSS animations
        const style = document.createElement('style');
        style.textContent = `
            .loading {
                display: inline-block;
                width: 20px;
                height: 20px;
                border: 3px solid rgba(255, 255, 255, 0.3);
                border-radius: 50%;
                border-top-color: var(--primary-color);
                animation: spin 1s ease-in-out infinite;
            }
            
            @keyframes spin {
                to { transform: rotate(360deg); }
            }
            
            .modal-content {
                animation: modalFadeIn 0.3s ease;
            }
            
            @keyframes modalFadeIn {
                from { opacity: 0; transform: translateY(-20px); }
                to { opacity: 1; transform: translateY(0); }
            }
            
            .price-up {
                animation: priceUp 0.5s ease;
            }
            
            @keyframes priceUp {
                0% { color: #fff; }
                50% { color: var(--primary-color); transform: scale(1.05); }
                100% { color: #fff; }
            }
            
            .price-down {
                animation: priceDown 0.5s ease;
            }
            
            @keyframes priceDown {
                0% { color: #fff; }
                50% { color: var(--danger-color); transform: scale(1.05); }
                100% { color: #fff; }
            }
            
            .trade-update {
                animation: tradeUpdate 1s ease;
            }
            
            @keyframes tradeUpdate {
                0% { background-color: rgba(0, 255, 136, 0.1); }
                100% { background-color: transparent; }
            }
        `;
        document.head.appendChild(style);

        // Trading System Class
        class TradingSystem {
            constructor() {
                this.state = {
                    currentPrice: 1.08500,
                    previousPrice: 1.08500,
                    prediction: 'ANALYZING',
                    action: 'WAIT',
                    confidence: 0,
                    balance: 10000,
                    totalProfit: 0,
                    winRate: 0,
                    totalTrades: 0,
                    profitableTrades: 0,
                    mlAccuracy: 0,
                    mlSamples: 0,
                    mlCorrections: 0,
                    learningRate: 0,
                    cycleCount: 0,
                    nextCycle: 120,
                    cacheEfficiency: '0%',
                    apiCalls: '~240/day',
                    tradeStatus: 'NO_TRADE',
                    signalStrength: 0,
                    systemStatus: 'INITIALIZING',
                    activeTrade: null,
                    tradeHistory: [],
                    chartData: null,
                    priceSource: 'Loading...',
                    priceChange: 0,
                    lastUpdate: null,
                    eventSource: null,
                    updateInterval: null,
                    chartInstance: null,
                    isFirstLoad: true
                };

                this.init();
            }

            async init() {
                console.log('ðŸš€ Initializing Trading System...');
                
                try {
                    // Initial data fetch
                    await this.fetchAllData();
                    
                    // Set up real-time updates
                    this.setupEventSource();
                    
                    // Set up periodic state checks (backup)
                    this.updateInterval = setInterval(() => this.fetchStateIfStale(), 3000);
                    
                    // Set up chart refresh
                    setInterval(() => this.updateChart(), 5000);
                    
                    console.log('âœ… Trading System initialized');
                    
                    // Hide loading overlay
                    setTimeout(() => {
                        document.getElementById('loading-overlay').style.display = 'none';
                    }, 1000);
                    
                } catch (error) {
                    console.error('Initialization error:', error);
                    this.showNotification('Failed to initialize trading system', 'error');
                }
            }

            async fetchAllData() {
                try {
                    await Promise.all([
                        this.fetchTradingState(),
                        this.fetchTradeHistory(),
                        this.fetchMLStatus(),
                        this.fetchCacheStatus()
                    ]);
                } catch (error) {
                    console.error('Error fetching initial data:', error);
                    this.showNotification('Failed to load initial data', 'error');
                }
            }

            async fetchTradingState() {
                try {
                    const response = await fetch('/api/trading_state?_=' + Date.now());
                    const data = await response.json();
                    
                    // Only update if data changed
                    if (JSON.stringify(this.state.currentState) !== JSON.stringify(data)) {
                        this.handleStateUpdate(data);
                    }
                    
                    this.state.lastUpdate = new Date().toLocaleTimeString();
                    
                } catch (error) {
                    console.error('Error fetching trading state:', error);
                }
            }

            async fetchTradeHistory() {
                try {
                    const response = await fetch('/api/trade_history');
                    const data = await response.json();
                    
                    if (data.trades && data.trades.length > 0) {
                        this.state.tradeHistory = data.trades;
                        this.updateTradeHistoryTable();
                    }
                    
                } catch (error) {
                    console.error('Error fetching trade history:', error);
                }
            }

            async fetchMLStatus() {
                try {
                    const response = await fetch('/api/ml_status');
                    const data = await response.json();
                    this.updateMLStatus(data);
                } catch (error) {
                    console.error('Error fetching ML status:', error);
                }
            }

            async fetchCacheStatus() {
                try {
                    const response = await fetch('/api/cache_status');
                    const data = await response.json();
                    this.updateCacheStatus(data);
                } catch (error) {
                    console.error('Error fetching cache status:', error);
                }
            }

            handleStateUpdate(data) {
                // Store current state for comparison
                this.state.currentState = data;
                
                // Calculate price change
                const oldPrice = this.state.currentPrice;
                const newPrice = data.current_price || this.state.currentPrice;
                const priceChange = newPrice - oldPrice;
                
                // Update all state values
                this.state.currentPrice = newPrice;
                this.state.previousPrice = oldPrice;
                this.state.priceChange = priceChange;
                this.state.prediction = data.minute_prediction || 'ANALYZING';
                this.state.action = data.action || 'WAIT';
                this.state.confidence = data.confidence || 0;
                this.state.balance = data.balance || 10000;
                this.state.totalProfit = data.total_profit || 0;
                this.state.winRate = data.win_rate || 0;
                this.state.totalTrades = data.total_trades || 0;
                this.state.profitableTrades = data.profitable_trades || 0;
                this.state.tradeStatus = data.trade_status || 'NO_TRADE';
                this.state.signalStrength = data.signal_strength || 0;
                this.state.cycleCount = data.cycle_count || 0;
                this.state.nextCycle = data.next_cycle_in || 120;
                this.state.systemStatus = data.system_status || 'INITIALIZING';
                this.state.priceSource = data.data_source || 'Loading...';
                
                // Update ML metrics from state
                this.state.mlAccuracy = data.prediction_accuracy || 0;
                this.state.mlSamples = data.ml_data_points || 0;
                this.state.mlCorrections = data.ml_corrections_applied || 0;
                
                // Update active trade
                if (data.current_trade) {
                    this.state.activeTrade = data.current_trade;
                } else {
                    this.state.activeTrade = null;
                }
                
                // Update chart data if available
                if (data.chart_data) {
                    try {
                        this.state.chartData = JSON.parse(data.chart_data);
                        this.updateChart();
                    } catch (e) {
                        console.error('Error parsing chart data:', e);
                    }
                }
                
                // Calculate ML progress
                this.calculateMLProgress();
                
                // Update UI
                this.updateUI();
                
                // Update progress bars
                this.updateProgressBars();
                
                // Update active trade panel
                this.updateActiveTradePanel();
                
                // Trigger update animation
                this.triggerUpdateAnimation();
            }

            triggerUpdateAnimation() {
                const statsGrid = document.querySelector('.stats-grid');
                if (statsGrid) {
                    statsGrid.classList.add('updating');
                    setTimeout(() => {
                        statsGrid.classList.remove('updating');
                    }, 500);
                }
            }

            calculateMLProgress() {
                // Calculate ML learning progress
                const maxSamples = 50;
                const currentSamples = this.state.mlSamples;
                
                // Training progress (0-100%)
                this.state.trainingProgress = Math.min(100, (currentSamples / 10) * 100);
                
                // Accuracy progress (starts at 50%, improves to 95%)
                const baseAccuracy = 50;
                const maxAccuracy = 95;
                const accuracyGain = Math.min(maxAccuracy - baseAccuracy, currentSamples * 0.5);
                this.state.mlAccuracy = Math.round(baseAccuracy + accuracyGain);
                
                // Model confidence (based on samples and accuracy)
                this.state.modelConfidence = Math.min(100, 
                    (currentSamples / maxSamples) * 50 + 
                    (this.state.mlAccuracy / maxAccuracy) * 50
                );
                
                // Data quality (based on sample count)
                this.state.dataQuality = Math.min(100, (currentSamples / maxSamples) * 100);
                
                // Learning rate (improvement per sample)
                this.state.learningRate = currentSamples > 0 ? 
                    ((this.state.mlAccuracy - 50) / currentSamples).toFixed(2) : 0;
            }

            updateUI() {
                // Update price with animation
                this.animateValue('current-price', this.state.currentPrice.toFixed(5), 'price');
                
                // Update price source
                document.getElementById('price-source').textContent = `Source: ${this.state.priceSource}`;
                
                // Update price change
                const priceChangeElement = document.getElementById('price-change');
                if (priceChangeElement) {
                    priceChangeElement.textContent = `${this.state.priceChange >= 0 ? '+' : ''}${this.state.priceChange.toFixed(4)}`;
                    priceChangeElement.className = `stat-change ${this.state.priceChange >= 0 ? 'positive' : 'negative'}`;
                }
                
                // Update prediction with color
                const predictionElement = document.getElementById('prediction');
                if (predictionElement) {
                    predictionElement.textContent = this.state.prediction;
                    predictionElement.style.color = this.getPredictionColor(this.state.prediction);
                }
                
                // Update confidence
                this.animateValue('confidence', `${this.state.confidence.toFixed(1)}%`, 'text');
                
                // Update signal strength
                this.updateSignalStrength(this.state.signalStrength);
                
                // Update action with color
                const actionElement = document.getElementById('action');
                if (actionElement) {
                    actionElement.textContent = this.state.action;
                    actionElement.style.color = this.getActionColor(this.state.action);
                }
                
                // Update trade status
                const tradeStatusElement = document.getElementById('trade-status');
                if (tradeStatusElement) tradeStatusElement.textContent = this.state.tradeStatus;
                
                const signalValueElement = document.getElementById('signal-value');
                if (signalValueElement) signalValueElement.textContent = `${this.state.signalStrength}/3`;
                
                // Update balance and profit
                this.animateValue('balance', `$${this.state.balance.toFixed(2)}`, 'currency');
                this.animateValue('total-profit', `$${this.state.totalProfit.toFixed(2)}`, 'currency');
                
                // Update profit change
                const profitChangeElement = document.getElementById('profit-change');
                if (profitChangeElement) {
                    profitChangeElement.textContent = `${this.state.totalProfit >= 0 ? '+$' : '-$'}${Math.abs(this.state.totalProfit).toFixed(2)}`;
                    profitChangeElement.className = `stat-change ${this.state.totalProfit >= 0 ? 'positive' : 'negative'}`;
                }
                
                // Update performance
                this.animateValue('win-rate', `${this.state.winRate.toFixed(1)}%`, 'text');
                
                const totalTradesElement = document.getElementById('total-trades');
                if (totalTradesElement) totalTradesElement.textContent = this.state.totalTrades;
                
                const profitableTradesElement = document.getElementById('profitable-trades');
                if (profitableTradesElement) profitableTradesElement.textContent = this.state.profitableTrades;
                
                // Update ML metrics
                this.animateValue('ml-accuracy', `${this.state.mlAccuracy}%`, 'text');
                
                const mlSamplesElement = document.getElementById('ml-samples');
                if (mlSamplesElement) mlSamplesElement.textContent = this.state.mlSamples;
                
                const mlCorrectionsElement = document.getElementById('ml-corrections');
                if (mlCorrectionsElement) mlCorrectionsElement.textContent = this.state.mlCorrections;
                
                const learningRateElement = document.getElementById('learning-rate');
                if (learningRateElement) learningRateElement.textContent = `${this.state.learningRate}%`;
                
                // Update system status
                const systemStatusElement = document.getElementById('system-status-text');
                if (systemStatusElement) systemStatusElement.textContent = this.state.systemStatus;
                
                const cycleCountElement = document.getElementById('cycle-count');
                if (cycleCountElement) cycleCountElement.textContent = this.state.cycleCount;
                
                const nextCycleElement = document.getElementById('next-cycle');
                if (nextCycleElement) nextCycleElement.textContent = this.state.nextCycle;
                
                // Update status indicator
                const indicator = document.getElementById('system-status-indicator');
                if (indicator) {
                    indicator.className = `status-indicator ${this.getStatusColor(this.state.systemStatus)}`;
                }
                
                // Update last update time
                const updateElement = document.getElementById('last-update') || (() => {
                    const elem = document.createElement('div');
                    elem.id = 'last-update';
                    elem.style.cssText = 'position: fixed; bottom: 10px; right: 10px; font-size: 11px; color: #666;';
                    document.body.appendChild(elem);
                    return elem;
                })();
                updateElement.textContent = `Last update: ${this.state.lastUpdate}`;
                
                // Update ML status text
                const mlStatusElement = document.getElementById('ml-status');
                if (mlStatusElement) {
                    mlStatusElement.textContent = this.state.mlSamples >= 10 ? 'ACTIVE ðŸ¤–' : 'LEARNING...';
                    mlStatusElement.style.color = this.state.mlSamples >= 10 ? 'var(--primary-color)' : 'var(--warning-color)';
                }
            }

            animateValue(elementId, newValue, type = 'text') {
                const element = document.getElementById(elementId);
                if (!element) return;
                
                const oldValue = element.textContent;
                
                // Only animate if value changed
                if (oldValue !== newValue) {
                    // Add animation class based on value change
                    if (type === 'price') {
                        const oldNum = parseFloat(oldValue.replace(/[^0-9.-]+/g, ""));
                        const newNum = parseFloat(newValue.replace(/[^0-9.-]+/g, ""));
                        if (oldNum && newNum) {
                            element.classList.add(newNum > oldNum ? 'price-up' : 'price-down');
                            setTimeout(() => {
                                element.classList.remove('price-up', 'price-down');
                            }, 500);
                        }
                    }
                    
                    element.style.transition = 'all 0.3s ease';
                    element.style.transform = 'scale(1.1)';
                    element.style.color = '#00ff88';
                    
                    setTimeout(() => {
                        element.textContent = newValue;
                        element.style.transform = 'scale(1)';
                        setTimeout(() => {
                            element.style.color = '';
                        }, 300);
                    }, 150);
                } else {
                    element.textContent = newValue;
                }
            }

            updateSignalStrength(strength) {
                const signalElement = document.getElementById('signal-strength');
                if (!signalElement) return;
                
                const dots = signalElement.querySelectorAll('.signal-dot');
                
                dots.forEach((dot, index) => {
                    dot.classList.toggle('active', index < strength);
                });
            }

            updateProgressBars() {
                // Training progress
                const trainingProgress = document.getElementById('training-progress');
                if (trainingProgress) {
                    trainingProgress.style.width = `${this.state.trainingProgress}%`;
                    trainingProgress.style.transition = 'width 1s ease';
                }
                
                // Accuracy progress
                const accuracyProgress = document.getElementById('accuracy-progress');
                if (accuracyProgress) {
                    accuracyProgress.style.width = `${this.state.mlAccuracy}%`;
                    accuracyProgress.style.transition = 'width 1s ease';
                }
                
                // Model confidence
                const modelConfidence = document.getElementById('model-confidence');
                if (modelConfidence) {
                    modelConfidence.style.width = `${this.state.modelConfidence}%`;
                    modelConfidence.style.transition = 'width 1s ease';
                }
                
                // Update progress text
                const trainingText = document.getElementById('training-progress-text');
                if (trainingText) {
                    trainingText.textContent = `${this.state.mlSamples}/10 trades`;
                }
                
                const accuracyText = document.getElementById('accuracy-text');
                if (accuracyText) {
                    accuracyText.textContent = `${this.state.mlAccuracy}%`;
                }
                
                const confidenceText = document.getElementById('model-confidence-text');
                if (confidenceText) {
                    confidenceText.textContent = `${Math.round(this.state.modelConfidence)}%`;
                }
                
                // Update ML stats
                const correctionsCount = document.getElementById('ml-corrections-count');
                if (correctionsCount) {
                    correctionsCount.textContent = this.state.mlCorrections;
                }
                
                const learningRateValue = document.getElementById('learning-rate-value');
                if (learningRateValue) {
                    learningRateValue.textContent = `${this.state.learningRate}%`;
                }
                
                const dataQuality = document.getElementById('data-quality');
                if (dataQuality) {
                    dataQuality.textContent = `${this.state.dataQuality}%`;
                }
            }

            updateActiveTradePanel() {
                const tradePanel = document.getElementById('trade-panel');
                const tradeDetails = document.getElementById('trade-details');
                const tradeInfo = document.getElementById('trade-info');
                
                if (!tradePanel || !tradeDetails || !tradeInfo) return;
                
                if (this.state.activeTrade) {
                    // Trade is active
                    tradePanel.classList.add('trade-active');
                    tradeDetails.style.display = 'none';
                    tradeInfo.style.display = 'grid';
                    
                    const trade = this.state.activeTrade;
                    const currentPrice = this.state.currentPrice;
                    
                    // Calculate current P/L
                    let currentPL = 0;
                    if (trade.action === 'BUY') {
                        currentPL = (currentPrice - trade.entry_price) * 10000;
                    } else {
                        currentPL = (trade.entry_price - currentPrice) * 10000;
                    }
                    
                    // Calculate time remaining
                    const duration = trade.duration_seconds || 0;
                    const remaining = Math.max(0, 120 - duration);
                    const progress = (duration / 120) * 100;
                    
                    // Update trade info with animation
                    this.animateValue('trade-entry', trade.entry_price?.toFixed(5) || '1.08500', 'price');
                    
                    const plElement = document.getElementById('trade-pl');
                    if (plElement) {
                        plElement.textContent = `${currentPL >= 0 ? '+' : ''}${currentPL.toFixed(1)} pips`;
                        plElement.style.color = currentPL >= 0 ? 'var(--primary-color)' : 'var(--danger-color)';
                    }
                    
                    this.animateValue('trade-tp', trade.optimal_tp?.toFixed(5) || '1.08580', 'price');
                    this.animateValue('trade-sl', trade.optimal_sl?.toFixed(5) || '1.08450', 'price');
                    
                    const tpDistance = document.getElementById('tp-distance');
                    if (tpDistance) {
                        tpDistance.textContent = `${trade.tp_distance_pips || 8} pips`;
                    }
                    
                    const slDistance = document.getElementById('sl-distance');
                    if (slDistance) {
                        slDistance.textContent = `${trade.sl_distance_pips || 5} pips`;
                    }
                    
                    const timeElement = document.getElementById('trade-time');
                    if (timeElement) {
                        timeElement.textContent = `${Math.round(remaining)}s`;
                    }
                    
                    const progressBar = document.getElementById('trade-progress-bar');
                    if (progressBar) {
                        progressBar.style.width = `${progress}%`;
                        progressBar.style.transition = 'width 1s linear';
                    }
                    
                } else {
                    // No active trade
                    tradePanel.classList.remove('trade-active');
                    tradeDetails.style.display = 'block';
                    tradeInfo.style.display = 'none';
                }
            }

            updateTradeHistoryTable() {
                const tbody = document.getElementById('trade-history-body');
                if (!tbody) return;
                
                const trades = this.state.tradeHistory.slice(-10).reverse();
                
                if (trades.length === 0) {
                    tbody.innerHTML = `
                        <tr>
                            <td colspan="8" style="text-align: center; padding: 30px; color: #666;">
                                <i class="fas fa-clock"></i> Waiting for trades...
                            </td>
                        </tr>
                    `;
                    return;
                }
                
                tbody.innerHTML = trades.map(trade => `
                    <tr>
                        <td>${trade.id || '-'}</td>
                        <td>
                            <span style="color: ${trade.action === 'BUY' ? 'var(--primary-color)' : 'var(--danger-color)'}; 
                                  font-weight: bold;">
                                ${trade.action || '-'}
                            </span>
                        </td>
                        <td>${trade.entry_price ? trade.entry_price.toFixed(5) : '-'}</td>
                        <td>${trade.exit_price ? trade.exit_price.toFixed(5) : '-'}</td>
                        <td class="${trade.profit_pips >= 0 ? 'profit-positive' : 'profit-negative'}">
                            ${trade.profit_pips ? `${trade.profit_pips >= 0 ? '+' : ''}${trade.profit_pips.toFixed(1)}` : '-'}
                        </td>
                        <td>
                            <span style="color: ${this.getResultColor(trade.result)}; font-weight: bold;">
                                ${trade.result || '-'}
                            </span>
                        </td>
                        <td>${trade.confidence ? `${trade.confidence.toFixed(1)}%` : '-'}</td>
                        <td>${trade.entry_time ? new Date(trade.entry_time).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '-'}</td>
                    </tr>
                `).join('');
            }

            updateChart() {
                if (!this.state.chartData) {
                    // Create a simple chart if no data
                    this.createDefaultChart();
                    return;
                }
                
                try {
                    const chartDiv = document.getElementById('chart');
                    if (!chartDiv) return;
                    
                    const chartData = typeof this.state.chartData === 'string' 
                        ? JSON.parse(this.state.chartData) 
                        : this.state.chartData;
                    
                    if (this.state.chartInstance) {
                        Plotly.react('chart', chartData.data, chartData.layout);
                    } else {
                        this.state.chartInstance = Plotly.newPlot('chart', chartData.data, chartData.layout, {
                            responsive: true
                        });
                    }
                } catch (error) {
                    console.error('Error updating chart:', error);
                    this.createDefaultChart();
                }
            }

            createDefaultChart() {
                const chartDiv = document.getElementById('chart');
                if (!chartDiv) return;
                
                const trace = {
                    x: [1, 2, 3, 4, 5],
                    y: [1.0850, 1.0851, 1.0852, 1.0851, 1.0853],
                    mode: 'lines',
                    name: 'EUR/USD',
                    line: {color: '#00ff88', width: 3}
                };
                
                const layout = {
                    title: 'Live Price Chart - Loading...',
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: 'rgba(0,0,0,0)',
                    font: {color: '#fff'},
                    xaxis: {gridcolor: 'rgba(255,255,255,0.1)'},
                    yaxis: {gridcolor: 'rgba(255,255,255,0.1)'},
                    template: 'plotly_dark'
                };
                
                if (this.state.chartInstance) {
                    Plotly.react('chart', [trace], layout);
                } else {
                    this.state.chartInstance = Plotly.newPlot('chart', [trace], layout);
                }
            }

            setupEventSource() {
                if (this.state.eventSource) {
                    this.state.eventSource.close();
                }

                this.state.eventSource = new EventSource('/api/events');
                
                this.state.eventSource.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        this.handleEvent(data);
                    } catch (e) {
                        console.error('Error parsing SSE data:', e);
                    }
                };

                this.state.eventSource.onopen = () => {
                    console.log('âœ… SSE connection established');
                    this.showNotification('Real-time connection established', 'success');
                    this.state.systemStatus = 'CONNECTED';
                    this.updateUI();
                };

                this.state.eventSource.onerror = (error) => {
                    console.error('SSE connection error:', error);
                    this.showNotification('Real-time connection lost. Reconnecting...', 'warning');
                    this.state.systemStatus = 'RECONNECTING';
                    this.updateUI();
                    
                    // Reconnect after 5 seconds
                    setTimeout(() => this.setupEventSource(), 5000);
                };
            }

            handleEvent(data) {
                switch (data.type) {
                    case 'price_update':
                        this.handlePriceUpdate(data);
                        break;
                    case 'prediction_update':
                        this.handlePredictionUpdate(data);
                        break;
                    case 'cycle_update':
                        this.handleCycleUpdate(data);
                        break;
                    case 'trade_update':
                        this.handleTradeUpdate(data);
                        break;
                    case 'ml_update':
                        this.handleMLUpdate(data);
                        break;
                    case 'heartbeat':
                        this.handleHeartbeat(data);
                        break;
                    case 'error':
                        console.error('Server error:', data.message);
                        this.showNotification(`Server error: ${data.message}`, 'error');
                        break;
                }
            }

            handlePriceUpdate(data) {
                const oldPrice = this.state.currentPrice;
                const newPrice = data.price;
                this.state.priceChange = newPrice - oldPrice;
                this.state.currentPrice = newPrice;
                this.state.priceSource = data.source || 'API';
                
                // Update price display with animation
                this.animateValue('current-price', newPrice.toFixed(5), 'price');
                
                // Update price change indicator
                const priceChangeElement = document.getElementById('price-change');
                if (priceChangeElement) {
                    priceChangeElement.textContent = `${this.state.priceChange >= 0 ? '+' : ''}${this.state.priceChange.toFixed(4)}`;
                    priceChangeElement.className = `stat-change ${this.state.priceChange >= 0 ? 'positive' : 'negative'}`;
                }
                
                this.state.lastUpdate = new Date().toLocaleTimeString();
            }

            handlePredictionUpdate(data) {
                if (data.prediction !== this.state.prediction) {
                    this.state.prediction = data.prediction;
                    this.state.confidence = data.confidence;
                    this.state.signalStrength = data.signal_strength;
                    
                    // Update UI
                    const predictionElement = document.getElementById('prediction');
                    if (predictionElement) {
                        predictionElement.textContent = data.prediction;
                        predictionElement.style.color = this.getPredictionColor(data.prediction);
                    }
                    
                    this.animateValue('confidence', `${data.confidence.toFixed(1)}%`, 'text');
                    this.updateSignalStrength(data.signal_strength);
                    
                    const signalValueElement = document.getElementById('signal-value');
                    if (signalValueElement) {
                        signalValueElement.textContent = `${data.signal_strength}/3`;
                    }
                    
                    // Show notification for significant prediction changes
                    if (this.state.prediction !== 'ANALYZING' && this.state.confidence > 70) {
                        this.showNotification(`New prediction: ${data.prediction} (${data.confidence.toFixed(1)}% confidence)`, 'success');
                    }
                }
            }

            handleCycleUpdate(data) {
                this.state.cycleCount = data.cycle;
                this.state.nextCycle = data.next_cycle_in;
                
                const cycleCountElement = document.getElementById('cycle-count');
                if (cycleCountElement) cycleCountElement.textContent = data.cycle;
                
                const nextCycleElement = document.getElementById('next-cycle');
                if (nextCycleElement) nextCycleElement.textContent = data.next_cycle_in;
            }

            handleTradeUpdate(data) {
                this.state.activeTrade = data.trade;
                this.updateActiveTradePanel();
                
                // Show notification for trade updates
                if (data.trade && data.trade.action) {
                    const pl = data.trade.profit_pips || 0;
                    if (Math.abs(pl) > 5) { // Only notify significant P/L
                        this.showNotification(`${data.trade.action} trade: ${pl >= 0 ? '+' : ''}${pl.toFixed(1)} pips`, 
                            pl >= 0 ? 'success' : 'error');
                    }
                }
            }

            handleMLUpdate(data) {
                if (data.ml_ready && !this.state.mlReady) {
                    this.showNotification('ðŸ¤– ML Model is now active and auto-correcting!', 'success');
                }
                
                this.state.mlSamples = data.samples || this.state.mlSamples;
                this.state.mlAccuracy = data.accuracy || this.state.mlAccuracy;
                this.state.mlReady = data.ml_ready || false;
                
                // Update ML status
                const mlStatusElement = document.getElementById('ml-status');
                if (mlStatusElement) {
                    mlStatusElement.textContent = data.ml_ready ? 'ACTIVE ðŸ¤–' : 'LEARNING...';
                    mlStatusElement.style.color = data.ml_ready ? 'var(--primary-color)' : 'var(--warning-color)';
                }
                
                const mlSamplesElement = document.getElementById('ml-samples');
                if (mlSamplesElement) mlSamplesElement.textContent = this.state.mlSamples;
                
                this.animateValue('ml-accuracy', `${this.state.mlAccuracy}%`, 'text');
                
                // Calculate and update progress
                this.calculateMLProgress();
                this.updateProgressBars();
            }

            handleHeartbeat(data) {
                // Update timestamp
                this.state.lastUpdate = new Date().toLocaleTimeString();
                this.state.systemStatus = data.system_status || 'RUNNING';
                
                // Update status indicator
                const indicator = document.getElementById('system-status-indicator');
                if (indicator) {
                    indicator.className = `status-indicator ${this.getStatusColor(data.system_status)}`;
                }
            }

            fetchStateIfStale() {
                // If no update in last 5 seconds, force fetch
                const now = Date.now();
                const lastUpdateTime = this.state.lastUpdate ? 
                    new Date(this.state.lastUpdate).getTime() : 0;
                
                if (now - lastUpdateTime > 5000) {
                    this.fetchTradingState();
                }
            }

            updateMLStatus(data) {
                this.state.mlReady = data.ml_model_ready || false;
                this.state.mlSamples = data.training_samples || 0;
                
                const mlStatusElement = document.getElementById('ml-status');
                if (mlStatusElement) {
                    mlStatusElement.textContent = this.state.mlReady ? 'ACTIVE ðŸ¤–' : 'LEARNING...';
                    mlStatusElement.style.color = this.state.mlReady ? 'var(--primary-color)' : 'var(--warning-color)';
                }
            }

            updateCacheStatus(data) {
                this.state.cacheEfficiency = data.cache_efficiency || '0%';
                this.state.apiCalls = data.api_calls_today || '~240/day';
                
                const cacheEfficiencyElement = document.getElementById('cache-efficiency');
                if (cacheEfficiencyElement) cacheEfficiencyElement.textContent = this.state.cacheEfficiency;
                
                const apiCallsElement = document.getElementById('api-calls');
                if (apiCallsElement) apiCallsElement.textContent = this.state.apiCalls;
            }

            // Utility functions
            getPredictionColor(prediction) {
                switch(prediction) {
                    case 'BULLISH': return 'var(--primary-color)';
                    case 'BEARISH': return 'var(--danger-color)';
                    case 'NEUTRAL': return 'var(--warning-color)';
                    default: return '#fff';
                }
            }

            getActionColor(action) {
                switch(action) {
                    case 'BUY': return 'var(--primary-color)';
                    case 'SELL': return 'var(--danger-color)';
                    case 'WAIT': return 'var(--warning-color)';
                    default: return '#fff';
                }
            }

            getStatusColor(status) {
                if (!status) return 'status-yellow';
                if (status.includes('RUNNING') || status.includes('CONNECTED') || status.includes('ACTIVE')) 
                    return 'status-green';
                if (status.includes('INITIALIZING') || status.includes('CACHED') || status.includes('WAITING')) 
                    return 'status-yellow';
                return 'status-red';
            }

            getResultColor(result) {
                switch(result) {
                    case 'SUCCESS': return 'var(--primary-color)';
                    case 'FAILED': return 'var(--danger-color)';
                    case 'PARTIAL_SUCCESS': return 'var(--warning-color)';
                    default: return '#fff';
                }
            }

            showNotification(message, type = 'success') {
                const notification = document.getElementById('notification');
                const messageElement = document.getElementById('notification-message');
                
                if (!notification || !messageElement) return;
                
                messageElement.textContent = message;
                notification.className = `notification ${type}`;
                notification.style.display = 'block';
                
                // Auto-hide after 5 seconds
                setTimeout(() => {
                    notification.style.display = 'none';
                }, 5000);
            }

            // User actions
            async refreshAllData() {
                this.showNotification('Refreshing all data...', 'success');
                await this.fetchAllData();
                this.showNotification('Data refreshed successfully', 'success');
            }

            async viewTradeHistory() {
                try {
                    await this.fetchTradeHistory();
                    const historyModal = document.getElementById('history-modal') || this.createModal('Trade History');
                    historyModal.style.display = 'block';
                } catch (error) {
                    this.showNotification('Failed to fetch trade history', 'error');
                }
            }

            async viewMLData() {
                try {
                    const response = await fetch('/api/view_ml_data');
                    const data = await response.json();
                    
                    if (data.error) {
                        this.showNotification(data.error, 'error');
                        return;
                    }
                    
                    const modal = document.getElementById('ml-modal') || this.createModal('ML Training Data');
                    modal.querySelector('.modal-content').innerHTML = `
                        <h3>${data.file}</h3>
                        <p>Total Lines: ${data.total_lines}</p>
                        <p>Training Samples: ${data.ml_status?.samples || 0}</p>
                        <p>ML Model Ready: ${data.ml_status?.ready ? 'Yes ðŸ¤–' : 'No'}</p>
                        <div style="max-height: 300px; overflow-y: auto; margin-top: 20px; background: rgba(0,0,0,0.3); padding: 15px; border-radius: 5px;">
                            <pre style="color: #aaa; font-size: 12px;">${JSON.stringify(data.preview || {}, null, 2)}</pre>
                        </div>
                    `;
                    modal.style.display = 'block';
                    
                } catch (error) {
                    this.showNotification('Failed to fetch ML data', 'error');
                }
            }

            async viewAdvancedMetrics() {
                try {
                    const response = await fetch('/api/advanced_metrics');
                    const data = await response.json();
                    
                    const modal = document.getElementById('metrics-modal') || this.createModal('Advanced Metrics');
                    modal.querySelector('.modal-content').innerHTML = `
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
                            <div class="stat-card">
                                <h4>Total Pips</h4>
                                <div class="stat-value">${data.total_pips?.toFixed(1) || 0}</div>
                            </div>
                            <div class="stat-card">
                                <h4>Best Trade</h4>
                                <div class="stat-value">${data.best_trade_pips?.toFixed(1) || 0}</div>
                            </div>
                            <div class="stat-card">
                                <h4>Worst Trade</h4>
                                <div class="stat-value">${data.worst_trade_pips?.toFixed(1) || 0}</div>
                            </div>
                            <div class="stat-card">
                                <h4>Avg Win</h4>
                                <div class="stat-value">${data.avg_win_pips?.toFixed(1) || 0}</div>
                            </div>
                            <div class="stat-card">
                                <h4>Avg Loss</h4>
                                <div class="stat-value">${data.avg_loss_pips?.toFixed(1) || 0}</div>
                            </div>
                            <div class="stat-card">
                                <h4>Profit Factor</h4>
                                <div class="stat-value">${data.profit_factor?.toFixed(2) || 0}</div>
                            </div>
                            <div class="stat-card">
                                <h4>Expectancy</h4>
                                <div class="stat-value">${data.expectancy?.toFixed(2) || 0}</div>
                            </div>
                            <div class="stat-card">
                                <h4>Max Drawdown</h4>
                                <div class="stat-value">${data.max_drawdown?.toFixed(1) || 0}%</div>
                            </div>
                        </div>
                    `;
                    modal.style.display = 'block';
                    
                } catch (error) {
                    this.showNotification('Failed to fetch advanced metrics', 'error');
                }
            }

            async forceMLTraining() {
                try {
                    const response = await fetch('/api/force_ml_training', { method: 'POST' });
                    const data = await response.json();
                    
                    if (data.success) {
                        this.showNotification(data.message, 'success');
                        await this.fetchMLStatus();
                    } else {
                        this.showNotification(data.message, 'error');
                    }
                } catch (error) {
                    this.showNotification('Failed to force ML training', 'error');
                }
            }

            async resetTrading() {
                if (!confirm('âš ï¸ Are you sure you want to reset the trading system?\n\nThis will:\nâ€¢ Clear all trade history\nâ€¢ Reset balance to $10,000\nâ€¢ Clear ML training data\nâ€¢ Reset all statistics\n\nThis action cannot be undone!')) {
                    return;
                }
                
                try {
                    const response = await fetch('/api/reset_trading', { method: 'POST' });
                    const data = await response.json();
                    
                    if (data.success) {
                        this.showNotification(data.message, 'success');
                        setTimeout(() => {
                            this.refreshAllData();
                        }, 1000);
                    } else {
                        this.showNotification(data.message, 'error');
                    }
                } catch (error) {
                    this.showNotification('Failed to reset trading', 'error');
                }
            }

            createModal(title) {
                const modal = document.createElement('div');
                modal.id = `${title.toLowerCase().replace(/\s+/g, '-')}-modal`;
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.8);
                    z-index: 9999;
                    display: none;
                    align-items: center;
                    justify-content: center;
                `;
                
                const content = document.createElement('div');
                content.className = 'modal-content';
                content.style.cssText = `
                    background: var(--card-bg);
                    padding: 30px;
                    border-radius: 15px;
                    max-width: 800px;
                    width: 90%;
                    max-height: 80vh;
                    overflow-y: auto;
                    border: 1px solid var(--border-color);
                `;
                
                content.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3>${title}</h3>
                        <button onclick="this.parentElement.parentElement.parentElement.style.display='none'" 
                                style="background: none; border: none; color: #fff; font-size: 24px; cursor: pointer;">
                            &times;
                        </button>
                    </div>
                `;
                
                modal.appendChild(content);
                document.body.appendChild(modal);
                
                // Close modal when clicking outside
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.style.display = 'none';
                    }
                });
                
                return modal;
            }
        }
    </script>
</body>
</html>